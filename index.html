<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Interactive Campus Map - Accurate Layout</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }
        
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            max-width: 320px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
        }
        
        #ui-overlay h1 {
            color: #2c3e50;
            font-size: 22px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #ui-overlay h1:before {
            content: "üèõÔ∏è";
            font-size: 24px;
        }
        
        .legend {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 2px solid #eee;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            flex-direction: column;
            z-index: 100;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            min-width: 160px;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            background: white;
        }
        
        .control-btn.active {
            background: #4CAF50;
            color: white;
        }
        
        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
            z-index: 100;
        }
        
        #info-panel h3 {
            color: #4CAF50;
            margin-bottom: 8px;
            font-size: 16px;
        }
        
        #info-panel p {
            margin: 5px 0;
            font-size: 14px;
            opacity: 0.9;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .instructions {
            background: rgba(52, 152, 219, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }
        
        .instruction-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 13px;
            color: #34495e;
        }
        
        .instruction-item:before {
            margin-right: 10px;
            font-size: 16px;
        }
        
        #coordinates {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading 3D Campus...</div>
        <div style="font-size: 14px; margin-top: 10px; opacity: 0.8;">Based on your architectural plan</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-overlay">
    <div class="controls-header">
        <h1>Campus Academic Block</h1>
        <button id="minimize-btn" class="minimize-btn" title="Minimize instructions">‚àí</button>
    </div>
    <div class="instructions">
        <div class="instruction-item">üñ±Ô∏è <strong>Left Drag:</strong> Rotate View</div>
        <div class="instruction-item">üñ±Ô∏è <strong>Right Drag:</strong> Pan View</div>
        <div class="instruction-item">üîç <strong>Scroll:</strong> Zoom In/Out</div>
        <div class="instruction-item">üëÜ <strong>Hover:</strong> See Details</div>
        <div class="instruction-item">üéØ <strong>Click:</strong> Focus View</div>
    </div>
</div>

<style>
#ui-overlay {
    position: fixed;
    top: 20px;
    left: 20px;
    background: rgba(255, 255, 255, 0.95);
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    max-width: 280px;
    transition: all 0.3s ease;
    border: 1px solid rgba(0, 0, 0, 0.1);
}

.controls-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.controls-header h1 {
    margin: 0;
    font-size: 18px;
    color: #2c3e50;
    font-weight: 600;
}

.minimize-btn {
    background: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    width: 30px;
    height: 30px;
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s ease;
    padding: 0;
    line-height: 1;
}

.minimize-btn:hover {
    background: #2980b9;
}

.instructions {
    overflow: hidden;
    transition: max-height 0.3s ease, opacity 0.3s ease;
}

.instruction-item {
    margin: 8px 0;
    font-size: 14px;
    color: #34495e;
    display: flex;
    align-items: flex-start;
    gap: 8px;
}

.instruction-item strong {
    color: #2c3e50;
    font-weight: 600;
}

/* Collapsed state */
#ui-overlay.collapsed {
    max-width: 200px;
}

#ui-overlay.collapsed .controls-header {
    margin-bottom: 0;
}

#ui-overlay.collapsed .instructions {
    max-height: 0;
    opacity: 0;
    margin: 0;
}

#ui-overlay.collapsed .minimize-btn::after {
    content: "+";
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const overlay = document.getElementById('ui-overlay');
    const minimizeBtn = document.getElementById('minimize-btn');
    const instructions = document.querySelector('.instructions');
    
    // Check if collapsed state is saved
    const isCollapsed = localStorage.getItem('uiOverlayCollapsed') === 'true';
    
    if (isCollapsed) {
        overlay.classList.add('collapsed');
    }
    
    minimizeBtn.addEventListener('click', function() {
        overlay.classList.toggle('collapsed');
        
        // Save state to localStorage
        localStorage.setItem('uiOverlayCollapsed', overlay.classList.contains('collapsed'));
    });
    
    // Optional: Auto-collapse after 10 seconds of inactivity
    let activityTimer;
    function resetActivityTimer() {
        clearTimeout(activityTimer);
        if (!overlay.classList.contains('collapsed')) {
            activityTimer = setTimeout(() => {
                overlay.classList.add('collapsed');
                localStorage.setItem('uiOverlayCollapsed', 'true');
            }, 10000); // 10 seconds
        }
    }
    
    // Reset timer on user interaction
    document.addEventListener('mousemove', resetActivityTimer);
    document.addEventListener('click', resetActivityTimer);
    document.addEventListener('scroll', resetActivityTimer);
    
    // Start the timer
    resetActivityTimer();
});
</script>
        <div class="legend">
            <div class="legend-item">
                <div class="color-box" style="background-color: #d4cdb4;"></div>
                <span>Buildings & Rooms</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background-color: #a8c4a0;"></div>
                <span>Courtyards & Gardens</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background-color: #b0b0b0;"></div>
                <span>Stairs</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background-color: #8c8c8c;"></div>
                <span>Walls</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background-color: #8b4513;"></div>
                <span>Gates</span>
            </div>
        </div>
    </div>

   <div class="controls-container">
    <div class="controls-panel">
        <button class="control-btn" onclick="resetView()">
            <span>üéØ</span> Reset View
        </button>
        <button class="control-btn" onclick="toggleGrid()" id="gridBtn">
            <span>‚¨ú</span> Show Grid
        </button>
        <button class="control-btn" onclick="toggleShadows()" id="shadowBtn">
            <span>üåì</span> Shadows On
        </button>
        <button class="control-btn" onclick="toggleLabels()" id="labelBtn">
            <span>üè∑Ô∏è</span> Hide Labels
        </button>
        <button class="control-btn" onclick="toggleAutoRotate()" id="rotateBtn">
            <span>üîÑ</span> Auto Rotate
        </button>
        <button class="toggle-controls-btn" id="toggleControlsBtn" title="Hide controls">
            ‚ñ≤
        </button>
    </div>
</div>

<style>
.controls-container {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    z-index: 999;
    padding: 20px;
    transition: transform 0.3s ease;
}

.controls-container.hidden {
    transform: translateY(-100%);
}

.controls-panel {
    display: flex;
    gap: 10px;
    background: rgba(255, 255, 255, 0.95);
    padding: 12px 20px 12px 20px;
    border-radius: 0 0 25px 25px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-top: none;
    backdrop-filter: blur(10px);
    position: relative;
}

.toggle-controls-btn {
    position: absolute;
    bottom: -25px;
    left: 50%;
    transform: translateX(-50%);
    width: 40px;
    height: 25px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-top: none;
    border-radius: 0 0 10px 10px;
    cursor: pointer;
    font-size: 12px;
    color: #666;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.toggle-controls-btn:hover {
    background: white;
    color: #3498db;
}

.controls-container.hidden .toggle-controls-btn {
    bottom: -40px;
    border-radius: 0 0 10px 10px;
}

.controls-container.hidden .toggle-controls-btn::after {
    content: "‚ñº";
}

.control-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 18px;
    background: white;
    border: 2px solid #e0e0e0;
    border-radius: 30px;
    font-size: 14px;
    font-weight: 500;
    color: #2c3e50;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
}

.control-btn:hover {
    background: #f8f9fa;
    border-color: #3498db;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(52, 152, 219, 0.2);
}

.control-btn:active {
    transform: translateY(0);
}

.control-btn span {
    font-size: 16px;
}

@media (max-width: 768px) {
    .controls-panel {
        flex-wrap: wrap;
        justify-content: center;
        border-radius: 0 0 20px 20px;
        padding: 10px;
        max-width: 90%;
    }
    
    .control-btn {
        padding: 8px 14px;
        font-size: 13px;
    }
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const controlsContainer = document.querySelector('.controls-container');
    const toggleBtn = document.getElementById('toggleControlsBtn');
    
    // Check if hidden state is saved
    const isHidden = localStorage.getItem('controlsHidden') === 'true';
    
    if (isHidden) {
        controlsContainer.classList.add('hidden');
    }
    
    toggleBtn.addEventListener('click', function() {
        controlsContainer.classList.toggle('hidden');
        
        // Save state to localStorage
        localStorage.setItem('controlsHidden', controlsContainer.classList.contains('hidden'));
    });
});
</script>
    <div id="info-panel">
        <h3 id="info-title">Building Information</h3>
        <p id="info-name">Hover over a building</p>
        <p id="info-type">Type: -</p>
        <p id="info-size">Size: -</p>
        <p id="info-description">Description will appear here</p>
    </div>

    <div id="coordinates">X: 0.0, Y: 0.0, Z: 0.0</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==================== GLOBAL VARIABLES ====================
        let scene, camera, renderer, controls, raycaster, mouse;
        let interactiveObjects = [];
        let hoveredObject = null;
        let gridHelper, axesHelper;
        let autoRotate = false;
        let labelsVisible = true;
        let buildingLabels = [];
        
        const tooltip = document.getElementById('info-panel');
        const loadingElement = document.getElementById('loading');
        const coordinateDisplay = document.getElementById('coordinates');
        const gridBtn = document.getElementById('gridBtn');
        const shadowBtn = document.getElementById('shadowBtn');
        const labelBtn = document.getElementById('labelBtn');
        const rotateBtn = document.getElementById('rotateBtn');

        // Colors from the legend in the image
        const COLORS = {
            // Buildings (from legend - room blocks)
            building: 0xd4cdb4,      // Light beige for rooms
            office: 0xc4b5a0,        // Slightly darker for offices
            lab: 0xb8c9d4,           // Blueish tint for labs
            special: 0xd9c8b0,       // Special rooms
            
            // Legend items
            walls: 0x8c8c8c,         // Grey walls
            courtyard: 0xa8c4a0,     // Green courtyards
            garden: 0x90b090,        // Slightly different green for gardens
            stairs: 0xb0b0b0,        // Grey stairs
            circulation: 0xe0e0e0,   // Light grey for paths
            
            // Additional
            gate: 0x8b4513,          // Brown gates
            ground: 0xebe5d3,        // Paper/ground color
            highlight: 0xffd700,     // Gold highlight
            roof: 0xb0a080           // Roof color
        };

        // Campus dimensions based on scale (140m x 100m from earlier)
        const MAP_WIDTH = 140;
        const MAP_DEPTH = 100;
        const WALL_HEIGHT = 10;
        const ROOM_HEIGHT = 8;
        const GATE_HEIGHT = 12;

        // ==================== INITIALIZATION ====================
        async function init() {
            try {
                // 1. Setup Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Sky blue
                
                // Add sky gradient
                const skyColor = 0xB1E1FF;
                const groundColor = 0xB97A20;
                scene.fog = new THREE.Fog(skyColor, 50, 300);
                
                // 2. Setup Camera
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(-30, 80, 80);
                
                // 3. Setup Renderer
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputEncoding = THREE.sRGBEncoding;
                document.getElementById('canvas-container').appendChild(renderer.domElement);
                
                // 4. Lighting
                setupLighting();
                
                // 5. Controls
                setupControls();
                
                // 6. Create Environment
                createEnvironment();
                
                // 7. Setup Interaction
                setupInteraction();
                
                // Hide loading screen
                setTimeout(() => {
                    loadingElement.style.opacity = '0';
                    setTimeout(() => {
                        loadingElement.style.display = 'none';
                    }, 500);
                }, 1000);
                
                // Start animation
                animate();
                
            } catch (error) {
                console.error('Initialization error:', error);
                loadingElement.innerHTML = `
                    <div style="color: #ff6b6b; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 20px;">‚ö†Ô∏è</div>
                        <div>Failed to load 3D Map</div>
                        <div style="font-size: 14px; margin-top: 10px;">${error.message}</div>
                        <button onclick="location.reload()" style="margin-top: 20px; padding: 10px 20px; background: white; border: none; border-radius: 5px; cursor: pointer;">
                            Retry
                        </button>
                    </div>
                `;
            }
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // Main directional light (sun)
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            scene.add(sunLight);
            
            // Helper to visualize light direction (comment out for production)
            // const helper = new THREE.DirectionalLightHelper(sunLight, 5);
            // scene.add(helper);
            
            // Fill light from opposite side
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-50, 30, -50);
            scene.add(fillLight);
            
            // Hemisphere light for sky/ground
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x8B7355, 0.2);
            scene.add(hemisphereLight);
        }

        function setupControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true;
            controls.minDistance = 10;
            controls.maxDistance = 300;
            controls.maxPolarAngle = Math.PI / 2;
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN
            };
            
            // Double click to reset
            renderer.domElement.addEventListener('dblclick', resetView);
        }

        function setupInteraction() {
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Event listeners
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', onMouseClick);
            
            // Prevent right-click context menu on canvas
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        // ==================== BUILDING FUNCTIONS ====================
        function createEnvironment() {
            // Ground plane
            createGround();
            
            // Create walls based on image layout
            createWalls();
            
            // Create buildings based on labels in the image
            createBuildings();
            
            // Create courtyards and gardens
            createCourtyards();
            
            // Create gates
            createGates();
            
            // Create paths and circulation
            createPaths();
            
            // Add helpers
            gridHelper = new THREE.GridHelper(MAP_WIDTH, 20, 0x888888, 0xcccccc);
            gridHelper.position.y = 0.1;
            gridHelper.visible = false;
            scene.add(gridHelper);
            
            axesHelper = new THREE.AxesHelper(20);
            axesHelper.position.y = 0.1;
            scene.add(axesHelper);
            
            // Add some trees for visual reference
            addVegetation();
        }

        function createGround() {
            // Main ground
            const groundGeometry = new THREE.PlaneGeometry(MAP_WIDTH + 40, MAP_DEPTH + 40);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: COLORS.ground,
                roughness: 1,
                metalness: 0
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createWalls() {
            // Perimeter walls - following the layout from image
            const wallThickness = 1.5;
            
            // Top wall (with Gate 3)
            createWallSegment(0, -MAP_DEPTH/2 + 1, MAP_WIDTH, wallThickness, WALL_HEIGHT);
            
            // Left wall (with Gate 2)
            createWallSegment(-MAP_WIDTH/2 + 1, 0, wallThickness, MAP_DEPTH, WALL_HEIGHT);
            
            // Right wall
            createWallSegment(MAP_WIDTH/2 - 1, 0, wallThickness, MAP_DEPTH, WALL_HEIGHT);
            
            // Bottom wall (with Gate 1)
            createWallSegment(-30, MAP_DEPTH/2 - 1, 60, wallThickness, WALL_HEIGHT);
            createWallSegment(40, MAP_DEPTH/2 - 1, 40, wallThickness, WALL_HEIGHT);
            
            // Internal walls for building separation
            createWallSegment(-20, 30, wallThickness, 40, WALL_HEIGHT);
            createWallSegment(20, 30, wallThickness, 40, WALL_HEIGHT);
            createWallSegment(0, 10, 60, wallThickness, WALL_HEIGHT);
        }

        function createWallSegment(x, z, width, depth, height) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: COLORS.walls,
                roughness: 0.8,
                metalness: 0.2
            });
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(x, height/2, z);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            return wall;
        }

        function createBuildings() {
            // Based on labels from the image
            
            // 1. Principle Office Block (Top-left cluster)
            createBuilding(-50, -35, 25, 20, ROOM_HEIGHT, 
                "Principle Office", "office", ["Principle Office", "Office Block", "Staff Room", "Room-1"]);
            
            // 2. Lab Block (Top-right)
            createBuilding(40, -35, 30, 20, ROOM_HEIGHT, 
                "Science Labs", "lab", ["Lab-1", "Lab-2", "Room-1"]);
            
            // 3. Admit Gate Block & Canteen (Top-center)
            createBuilding(-10, -25, 25, 15, ROOM_HEIGHT, 
                "Admit Block & Canteen", "special", ["Admit gate block", "Canteen"]);
            
            // 4. Lecture Hall Block (Left side)
            createBuilding(-55, 15, 18, 50, ROOM_HEIGHT + 2, 
                "Lecture Halls", "building", ["Lecture Hall", "Laboratory", "Lecture Hall"]);
            
            // 5. Central Staircase Block (Center)
            createBuilding(0, 0, 25, 30, ROOM_HEIGHT + 4, 
                "Central Block", "stairs", ["Staircase", "Room Upstairs", "Room-1/2"]);
            
            // 6. Library & Lab 3 Block (Right side)
            createBuilding(55, 15, 18, 50, ROOM_HEIGHT, 
                "Library & Labs", "lab", ["Library", "Lab-3", "Room-5"]);
            
            // 7. Common Room Block (Bottom-left)
            createBuilding(-45, 40, 30, 15, ROOM_HEIGHT, 
                "Common Room Block", "building", ["Room-8", "Common Room", "Store"]);
            
            // 8. Classroom Block (Bottom-right)
            createBuilding(45, 40, 30, 20, ROOM_HEIGHT, 
                "Classroom Block", "building", ["Room-5", "Room-6"]);
            
            // Add roofs with slight overhang
            addRoofs();
        }

        function createBuilding(x, z, width, depth, height, name, type, rooms) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: COLORS[type],
                roughness: 0.7,
                metalness: 0.1
            });
            
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height/2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            
            // Store building data
            building.userData = {
                name: name,
                type: type,
                rooms: rooms,
                originalColor: COLORS[type],
                width: width,
                depth: depth,
                height: height
            };
            
            scene.add(building);
            interactiveObjects.push(building);
            
            // Add label
            addLabel(building, name);
            
            return building;
        }

        function addRoofs() {
            // Simple flat roofs for each building
            const roofHeight = 0.5;
            
            // Add roofs to main buildings
            const buildings = [
                { x: -50, z: -35, w: 28, d: 22 },
                { x: 40, z: -35, w: 32, d: 22 },
                { x: -10, z: -25, w: 27, d: 17 },
                { x: -55, z: 15, w: 20, d: 52 },
                { x: 0, z: 0, w: 27, d: 32 },
                { x: 55, z: 15, w: 20, d: 52 },
                { x: -45, z: 40, w: 32, d: 17 },
                { x: 45, z: 40, w: 32, d: 22 }
            ];
            
            buildings.forEach(b => {
                const roofGeometry = new THREE.BoxGeometry(b.w, roofHeight, b.d);
                const roofMaterial = new THREE.MeshStandardMaterial({ 
                    color: COLORS.roof,
                    roughness: 0.9,
                    metalness: 0.1
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(b.x, ROOM_HEIGHT + roofHeight/2, b.z);
                roof.receiveShadow = true;
                scene.add(roof);
            });
        }

        function createCourtyards() {
            // Based on the image, create green courtyard areas
            
            // Main central courtyard
            createCourtyard(-10, 0, 40, 50, "Main Courtyard");
            
            // Left garden
            createCourtyard(-35, 15, 25, 40, "Left Garden");
            
            // Right garden areas
            createCourtyard(25, 10, 20, 30, "Stairs Garden");
            createCourtyard(35, 30, 20, 20, "Right Garden");
            
            // Top gardens
            createCourtyard(-30, -25, 20, 15, "Office Garden");
            createCourtyard(25, -25, 20, 15, "Lab Garden");
        }

        function createCourtyard(x, z, width, depth, name) {
            const geometry = new THREE.BoxGeometry(width, 0.3, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: COLORS.courtyard,
                roughness: 0.9,
                metalness: 0
            });
            
            const courtyard = new THREE.Mesh(geometry, material);
            courtyard.position.set(x, 0.15, z);
            courtyard.receiveShadow = true;
            
            courtyard.userData = {
                name: name,
                type: 'courtyard',
                originalColor: COLORS.courtyard
            };
            
            scene.add(courtyard);
            interactiveObjects.push(courtyard);
            
            // Add some grass texture with small patches
            addGrassPatches(x, z, width, depth);
            
            return courtyard;
        }

        function addGrassPatches(x, z, width, depth) {
            // Add random small grass patches
            for (let i = 0; i < 20; i++) {
                const patchX = x + (Math.random() - 0.5) * width * 0.8;
                const patchZ = z + (Math.random() - 0.5) * depth * 0.8;
                
                const grassGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 6);
                const grassMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x7cb342,
                    roughness: 1,
                    metalness: 0
                });
                
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.position.set(patchX, 0.25, patchZ);
                grass.rotation.y = Math.random() * Math.PI;
                scene.add(grass);
            }
        }

        function createGates() {
            // Gate 1 (Bottom/Main Gate)
            createGate(0, MAP_DEPTH/2 - 5, "Main Gate 1", 0);
            
            // Gate 2 (Left side)
            createGate(-MAP_WIDTH/2 + 5, -10, "Main Gate 2", Math.PI/2);
            
            // Gate 3 (Top)
            createGate(0, -MAP_DEPTH/2 + 5, "Main Gate 3", Math.PI);
        }

        function createGate(x, z, name, rotationY) {
            // Gate pillars
            const pillarGeometry = new THREE.CylinderGeometry(0.8, 1, GATE_HEIGHT, 8);
            const pillarMaterial = new THREE.MeshStandardMaterial({ 
                color: COLORS.gate,
                roughness: 0.6,
                metalness: 0.4
            });
            
            const leftPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            const rightPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            
            leftPillar.position.set(x - 3.5, GATE_HEIGHT/2, z);
            rightPillar.position.set(x + 3.5, GATE_HEIGHT/2, z);
            
            leftPillar.castShadow = true;
            rightPillar.castShadow = true;
            
            // Arch/lintel
            const lintelGeometry = new THREE.BoxGeometry(8, 1, 1);
            const lintel = new THREE.Mesh(lintelGeometry, pillarMaterial);
            lintel.position.set(x, GATE_HEIGHT - 0.5, z);
            lintel.castShadow = true;
            
            // Group and rotate
            const gateGroup = new THREE.Group();
            gateGroup.add(leftPillar);
            gateGroup.add(rightPillar);
            gateGroup.add(lintel);
            gateGroup.rotation.y = rotationY;
            gateGroup.position.set(x, 0, z);
            
            // Interactive trigger
            const triggerGeometry = new THREE.BoxGeometry(8, GATE_HEIGHT, 3);
            const triggerMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.0,
                visible: false
            });
            
            const trigger = new THREE.Mesh(triggerGeometry, triggerMaterial);
            trigger.position.set(0, GATE_HEIGHT/2, 0);
            trigger.userData = {
                name: name,
                type: 'gate',
                originalColor: 0x000000
            };
            
            gateGroup.add(trigger);
            scene.add(gateGroup);
            
            interactiveObjects.push(trigger);
            
            // Add label above gate
            addGateLabel(x, GATE_HEIGHT + 2, z, name, rotationY);
            
            return gateGroup;
        }

        function createPaths() {
            // Main circulation paths between buildings
            const pathMaterial = new THREE.MeshStandardMaterial({ 
                color: COLORS.circulation,
                roughness: 0.9,
                metalness: 0
            });
            
            // Main entrance path
            createPath(0, 40, 10, 30, pathMaterial);
            
            // Cross paths
            createPath(0, 10, 60, 5, pathMaterial);
            createPath(-20, 15, 5, 50, pathMaterial);
            createPath(20, 15, 5, 50, pathMaterial);
            
            // Path to gates
            createPath(0, -45, 10, 20, pathMaterial);
            createPath(-60, -10, 10, 5, pathMaterial);
        }

        function createPath(x, z, width, depth, material) {
            const geometry = new THREE.BoxGeometry(width, 0.2, depth);
            const path = new THREE.Mesh(geometry, material);
            path.position.set(x, 0.1, z);
            path.receiveShadow = true;
            scene.add(path);
        }

        function addVegetation() {
            // Add trees around the campus
            const treePositions = [
                [-40, -20], [-30, 35], [30, 35], [40, -20],
                [-55, 0], [-55, 30], [55, 0], [55, 30],
                [-20, -40], [20, -40], [0, -45]
            ];
            
            treePositions.forEach(pos => {
                if (Math.random() > 0.3) {
                    createTree(pos[0], pos[1]);
                }
            });
            
            // Add some bushes
            for (let i = 0; i < 30; i++) {
                const bushX = (Math.random() - 0.5) * MAP_WIDTH * 0.8;
                const bushZ = (Math.random() - 0.5) * MAP_DEPTH * 0.8;
                
                // Avoid placing bushes on buildings
                if (Math.abs(bushX) < 60 && Math.abs(bushZ) < 40) continue;
                
                createBush(bushX, bushZ);
            }
        }

        function createTree(x, z) {
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, 2, z);
            trunk.castShadow = true;
            
            // Foliage (two layers for better look)
            const foliageGeometry1 = new THREE.SphereGeometry(2.5, 8, 6);
            const foliageGeometry2 = new THREE.SphereGeometry(2, 8, 6);
            const foliageMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2d5a27,
                roughness: 0.8
            });
            
            const foliage1 = new THREE.Mesh(foliageGeometry1, foliageMaterial);
            const foliage2 = new THREE.Mesh(foliageGeometry2, foliageMaterial);
            
            foliage1.position.set(x, 5.5, z);
            foliage2.position.set(x, 6.5, z);
            
            foliage1.castShadow = true;
            foliage2.castShadow = true;
            
            scene.add(trunk);
            scene.add(foliage1);
            scene.add(foliage2);
        }

        function createBush(x, z) {
            const bushGeometry = new THREE.SphereGeometry(1.2, 6, 4);
            const bushMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a7d34,
                roughness: 0.9
            });
            
            const bush = new THREE.Mesh(bushGeometry, bushMaterial);
            bush.position.set(x, 1, z);
            bush.castShadow = true;
            scene.add(bush);
        }

        // ==================== UI & LABELS ====================
        function addLabel(object, text) {
            // Create a canvas for the label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            
            // Draw background
            context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw border
            context.strokeStyle = '#4CAF50';
            context.lineWidth = 4;
            context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
            
            // Draw text
            context.fillStyle = '#2c3e50';
            context.font = 'bold 20px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Wrap text
            const words = text.split(' ');
            let line = '';
            let y = 30;
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i] + ' ';
                const metrics = context.measureText(testLine);
                if (metrics.width > 200 && i > 0) {
                    context.fillText(line, canvas.width / 2, y);
                    line = words[i] + ' ';
                    y += 30;
                } else {
                    line = testLine;
                }
            }
            context.fillText(line, canvas.width / 2, y);
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            
            // Create sprite
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.9
            });
            
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(
                object.position.x,
                object.position.y + object.userData.height + 3,
                object.position.z
            );
            
            sprite.scale.set(10, 5, 1);
            sprite.userData = { isLabel: true, building: object };
            sprite.visible = labelsVisible;
            
            scene.add(sprite);
            buildingLabels.push(sprite);
            
            return sprite;
        }

        function addGateLabel(x, y, z, text, rotationY) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = '#8B4513';
            context.font = 'bold 16px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
            
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(6, 3, 1);
            sprite.rotation.y = rotationY + Math.PI/2;
            sprite.visible = labelsVisible;
            
            scene.add(sprite);
            buildingLabels.push(sprite);
        }

        function toggleLabels() {
            labelsVisible = !labelsVisible;
            buildingLabels.forEach(label => {
                label.visible = labelsVisible;
            });
            labelBtn.innerHTML = labelsVisible ? 
                '<span>üè∑Ô∏è</span> Hide Labels' : 
                '<span>üè∑Ô∏è</span> Show Labels';
        }

        // ==================== INTERACTION ====================
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update coordinates display
            coordinateDisplay.textContent = 
                `X: ${mouse.x.toFixed(2)}, Y: ${mouse.y.toFixed(2)}`;
            
            // Update hover effects
            updateHover();
        }

        function updateHover() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactiveObjects);
            
            if (intersects.length > 0) {
                const target = intersects[0].object;
                
                if (hoveredObject !== target) {
                    // Reset previous hovered object
                    if (hoveredObject && hoveredObject.material) {
                        hoveredObject.material.color.setHex(hoveredObject.userData.originalColor);
                        hoveredObject.material.emissive?.setHex(0x000000);
                    }
                    
                    // Highlight new object
                    hoveredObject = target;
                    if (hoveredObject.material) {
                        hoveredObject.material.emissive = hoveredObject.material.emissive || new THREE.Color(0x000000);
                        hoveredObject.material.emissive.setHex(0x333300);
                        hoveredObject.material.needsUpdate = true;
                    }
                    
                    // Show info panel
                    showInfo(hoveredObject.userData);
                    document.body.style.cursor = 'pointer';
                }
            } else {
                // Not hovering over anything
                if (hoveredObject && hoveredObject.material) {
                    hoveredObject.material.color.setHex(hoveredObject.userData.originalColor);
                    hoveredObject.material.emissive?.setHex(0x000000);
                    hoveredObject = null;
                }
                
                tooltip.style.display = 'none';
                document.body.style.cursor = 'default';
            }
        }

        function showInfo(data) {
            if (!data) return;
            
            document.getElementById('info-title').textContent = data.name;
            document.getElementById('info-name').textContent = data.name;
            document.getElementById('info-type').textContent = `Type: ${data.type.charAt(0).toUpperCase() + data.type.slice(1)}`;
            
            if (data.width) {
                document.getElementById('info-size').textContent = 
                    `Size: ${data.width}m √ó ${data.depth}m √ó ${data.height}m`;
            } else {
                document.getElementById('info-size').textContent = '';
            }
            
            if (data.rooms) {
                document.getElementById('info-description').textContent = 
                    `Contains: ${data.rooms.join(', ')}`;
            } else {
                document.getElementById('info-description').textContent = 
                    data.type === 'gate' ? 'Main entrance point' :
                    data.type === 'courtyard' ? 'Green open space' :
                    'Building area';
            }
            
            tooltip.style.display = 'block';
        }

        function onMouseClick(event) {
            if (hoveredObject) {
                // Focus camera on clicked object
                const targetPosition = hoveredObject.position.clone();
                targetPosition.y += hoveredObject.userData.height || 10;
                
                // Animate camera to object
                const currentPosition = camera.position.clone();
                const targetCameraPosition = targetPosition.clone().add(
                    new THREE.Vector3(20, 20, 20)
                );
                
                // Simple linear interpolation for camera movement
                const duration = 1000; // ms
                const startTime = Date.now();
                
                function animateCamera() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Ease out
                    const ease = 1 - Math.pow(1 - progress, 3);
                    
                    camera.position.lerpVectors(currentPosition, targetCameraPosition, ease);
                    controls.target.lerp(targetPosition, ease);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateCamera);
                    }
                }
                
                animateCamera();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== CONTROL FUNCTIONS ====================
        function resetView() {
            camera.position.set(-30, 80, 80);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        function toggleGrid() {
            gridHelper.visible = !gridHelper.visible;
            gridBtn.innerHTML = gridHelper.visible ? 
                '<span>‚¨ú</span> Hide Grid' : 
                '<span>‚¨ú</span> Show Grid';
        }

        function toggleShadows() {
            renderer.shadowMap.enabled = !renderer.shadowMap.enabled;
            shadowBtn.innerHTML = renderer.shadowMap.enabled ? 
                '<span>üåì</span> Shadows On' : 
                '<span>üåì</span> Shadows Off';
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            controls.autoRotate = autoRotate;
            controls.autoRotateSpeed = 0.5;
            rotateBtn.innerHTML = autoRotate ? 
                '<span>üîÑ</span> Auto Rotate On' : 
                '<span>üîÑ</span> Auto Rotate Off';
        }

        // ==================== ANIMATION LOOP ====================
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            controls.update();
            
            // Animate labels to face camera
            if (labelsVisible) {
                buildingLabels.forEach(label => {
                    label.lookAt(camera.position);
                });
            }
            
            // Render
            renderer.render(scene, camera);
        }

        // ==================== INITIALIZE ====================
        init();

        // Make functions globally available
        window.resetView = resetView;
        window.toggleGrid = toggleGrid;
        window.toggleShadows = toggleShadows;
        window.toggleLabels = toggleLabels;
        window.toggleAutoRotate = toggleAutoRotate;
    </script>
</body>
</html>
